# 347. Top K Frequent Elements

## Description

See: [https://leetcode.com/problems/top-k-frequent-elements/](https://leetcode.com/problems/top-k-frequent-elements/)

> Given an integer array `nums` and an integer `k`, return _the_ `k` _most frequent elements_. You may return the answer in **any order**.
>
> **Constraints:**
>
> * `1 <= nums.length <= 105`
> * `k` is in the range `[1, the number of unique elements in the array]`.
> * It is **guaranteed** that the answer is **unique**.

## Solution

There are various solutions to this problem. I did the O(n log n) solution first, as I knew how to do that with a heap.

The followup to question is to do it in under O(n log n) time. I read up on how to do that. There are two approaches that give a O(n) solution.

In all solutions, the first step is to use a dict to map the numbers to their frequencies.

### Solution 1 - Heap - O(n log n)

Use a [heap](../../data-structures/binary-heap.md) as the max frequency will be at the root. Popping the root k times will give the k most frequent items.

Python has the built in [heapq](https://docs.python.org/3/library/heapq.html) module which makes working with heaps easy. It has the [heapq.nlargest](https://docs.python.org/3/library/heapq.html#heapq.nlargest) function which does which this question asks for.

```python
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        if len(nums) == k:
            return nums
        freq = Counter(nums)
        # return k elements for the iterable freq.keys() (numbers), sort by freq values (which is the frequency of each number)
        return heapq.nlargest(k, freq.keys(), key=freq.get)
        
```

Time Complexity: O(n log n) - heapify and retrieve the k elements

Space Complexity: O(n + k) - dict of `n` elements and Heap of `k` elements

### Solution 2 - Bucket Sort - O(n)

In this solution, an array is created that is the size of the num array. Why? Because if we are&#x20;

```python
class Solution:
    def topKFrequent_bucket_sort(self, nums: List[int], k: int) -> List[int]:
        if len(nums) == k:
            return nums
        freq = Counter(nums)
        buckets = [[] for i in range(len(nums) + 1)]
        for num, count in freq.items():
            buckets[count].append(num)

        result = []
        for i in range(len(buckets) - 1, 0, -1):
            for num in buckets[i]:
                result.append(num)
                if len(result) == k:
                    return result

```
